What are Sockets?
- Sockets are a method of Inter Process Communication that allows data to be exchanged b/w applications running on same host or different hosts.
- A Socket is simply a file descriptor which can be obtained using socket(), system call.
ex:
fd = socket();
- Any socket is described by 5-tuples:
      a: Sender IP.
	  b: Sender Port.
	  c: Receiver IP.
	  d: Receiver Port.
	  e: Communication protocol(TCP/UDP)

Internet Sockets:
--------------------------------------------------------------------------------------------------	  
- There are two types of internet sockets:
    1. Stream Sockets   AKA (SOCK_STREAM)
    2. Datagram Sockets	AKA (SOCK_DGRAM)
 
Stream Sockets (SOCK_STREAM):
------------------------------
Stream sockets are reliable, bi-directional, connection oriented byte stream.

Stream sockets make use of TCP/IP protocol stack.

 - Reliable => Means, if the data is sent, either it will be success or error. i.e no loss of packets.
               Data maintains correct sequencing i.e if we send 123 it will appear at receiver as 123 and 312 or 132.
 
 - Bi-directional => Means, data can be transmitted in either directions.

 - Byte-stream => Means, as with pipes there is no concept of message boundaries.
 
 - Connection oriented => connection is maintained b/w client and server. 
        

Datagram sockets (SOCK_DGRAM):
-------------------------------
Datagram sockets are non-reliable, connection less packets of data.

packets of data => Means, unlike byte-stream there exists message boundaries.
connectionless => No connection is maintained b/w sender and receiver. Its simply a fire and forget strategy.
Non-Reliable => You cannot rely on sequencing of data at receiver end. Also, packet loss can occur.
 
Datagram sockets make use of UDP/IP protocol stack.

Some applications making use of Datagram sockets are: dhcp, ping


Port Numbers:
--------------------
Port numbers are 16-bit numbers. They are used in conjunction with IP addresses as a socket identifier. (For both TCP and UDP)

What if there were no ports and only Ip addresses?
Ans: In such a case a socket can only be identified by 3-tuple i.e sourceIP:DestinationIP:Protocol. Thus, if two applications say mysql and apache needs to execute on same machine
they cannot as both will have same protocol i.e TCP and will have same sourceIP to bind to. Thus, ports helps us to run multiple services on same machine by binding them to 
different ports.  
NOTE: All ports under 1024 are reserved for root user.
Ephemeral ports: In case a client application does not explicitely binds itself to a port. Then, automatically a port is assigned to the application for sending request to server such
a port is called ephemeral port.
Ephemeral port range can be obtained from file: /proc/sys/net/ipv4/ip_local_port_range 



Socket System Calls:
--------------------------------------------------------------------------------------
1. socket() :=> Creates a new Socket.
    `int socket(int domain, int type, int protocol);` 
 - domain can be:
    AF_UNIX => For communication b/w applications on same host.
    AF_INET => communication using IPv4 addressing.
    AF_INET6 => communication using IPv6 addressing.

 - type specifies: Whether its a stream socket(SOCK_STREAM) or datagram(SOCK_DGRAM) socket.
 - protocol: This can simply be set to 0 and it will automatically chose correct protocol based on type specified.

2. bind() :=> Now, that you have got the socket. Next step is to specify the IP and Port to which you want to bind this socket. This is done using bind() system call.
   `int bind(int sockfd, struct sockaddr *my_addr, int addrlen);`
    - sockfd => file descriptor obtained from socket() call.
    - sockaddr => IP:Port to bind.
   NOTE: All ports under 1024 are reserved for root user.
   
   TIP: Sometimes, you will see that bind() failes with an error "Address already in use" but actually there is no application using the port. This happens because the application
        has ended, however still the socket binded to port is hanging in kernel. Such a hogging port will automatically get cleared in a minute or so. But if you want to totally remove
        this situation you can add option 'SO_REUSEADDR' in socket options.		
		
3. connect() :=> Now, we have created a socket, binded that socket to an Ip:Port, its time to connect to remote host. This is done via connect() system call.
                 Connect() syscall is used by clients in client-server paradigm.
         `int connect(int sockfd, struct sockaddr *serv_addr, int addrlen);`
          - sockfd => file descriptor obtained from socket() call.
          - sockaddr => Ip:PORT address of remote host.
      NOTE: We can also call connect() without making an explicit call to bind(). In such a case, connect will automatically call bind() internally and will choose a random port to bind socket to. 		  
	  NOTE: connect() is a blocking call and will block incase servers backlog Q is full, till server inserts the connection in backlog Q. See accept().
	  NOTE: For TCP sockets, connections are queued to baclog Q only after handshake is completed by kernel.
	
4. listen()	:=> Incase, we are building a server we need to listen for incoming connections. This is done via listen() system call.
             `int listen(int sockfd, int backlog);`
			 - sockfd  => file descriptor obtained from socket() call.
			 - backlog =>  Size of queue in which connections will wait till they are marked as accepted. Default is 20.
	  So, for the server to listen for incoming connections following is the system call sequencing:
	       socket() -> bind() -> listen().
		   NOTE: listen() syscall is always non-blocking.
		   
5. accept() :=> We don't want incoming connections to keep waiting in backlog, so we use accept() system call to pick a connection from backlog queue.
                Along with picking a connection and returning it to us, the accept() call does some extra work too. It creates a new socket for the returned connection
                and this new socket is used for any communication b/w the server and returned client connection.
                The old socket keeps on listening for more client connections. We need to call accept() in loop so that the program picks next connection once previous is accepted.
                Thus, if we have 10 active client connections we have 10+1 sockets. Where 1 (original) socket is listening for more clients and remaining 10 are serving I/O.
				//@todo: better describe this with figure.
           `int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);`
                  - sockfd => original socket descriptor obtained using socket() call.
                  - sockaddr => you dont need to fill this, it will be filled with client Ip and POrt once accept is called. 
				  
				NOTE: Accept() does not opens up a new port on host. It just returns a new socket which uses the servers binded port for communication.


                  127.0.0.1:3306 (sock) (server binded port)             
                  client calling from 1.1.1.1:2202
                  Accept() (sock1) -> [127.0.0.1:3306,1.1.1.1:2202,TCP]
              NOTE: accept() is a blocking call and will block if backlog queue is empty.				  

				

6. send() and recv() :=> These syscalls are used to send and receive data from stream sockets. For datagram sockets use receivefrom() and sendto()
                        NOTE: These needs to be called on new socket descriptor returned from accept() call not on listening socket.
                        NOTE: recv() is a blocking call and will block till an EOF is encountered.	

//@todo make a good figure to illustrate above client and server steps described above.						
						
						
						
STream Sockets:
---------------------------------------------
Stream sockets can be active or passive.						
						
Active vs Passive socket:
-----------------------------
Active: Any socket that can initiate a connection to another socket is called active sockets. ex: sockets opened by client programs.
Passive: Any socket that can only listen to incoming requests from other sockets but cannot initiate a connection is called passive socket. ex: listening sockets 
opened by server programs.

Blocking nature of calls:
----------------------------------
Connect() -> blocks if backlogQ at server is full.
Accept() -> blocks if backlogQ is empty i.e no client connection is waiting to be accepted. (Needs to be called in loop)
Read() -> Blocks till atleast 1 byte is read from remote end.Needs to be called in loop in order to read full data. But the problem is how will it know that it has read full data
and now needs to break out of loop as no more data will be sent via server. 
For this, we can use a delimeter byte and upon encountering that byte we can assume that full data has been transfered.Generally \n is used as delimeter byte.
NOTE: we cannot use EOF, as EOF occurs only if remote end closes connection.
Write() -> Does not block. But what happens when server is not ready to read???check this.


Byte ordering
------------------------------
Each memory address can store only one byte at max. 
So, if the data size is less than 1 byte than the data can be easily stored in a single address location.However,
if the data size exceeds 1 byte, the data needs to be stored in multiple address locations where each address location cannot hold more than 1 byte.
There are two main techniques of doing this: 
a:) Big Indian (MSB first) approach => In this Most significant byte is stored first and then the least significant byte.
b:) Little Indian (LSB first) approach. => In this Least significant byte is stored first and then the Most significant byte.
Fig: https://en.wikipedia.org/wiki/Endianness

NOTE: in MSB -> 1001010 <-LSB
Since Ipv4 addresses are 32bit(4byte) integers and port numbers are 16 bit(2byte) integers lets see this with an example.
TODO: Hex sounds cool, see below how simple its to convert bin-hex and vice verca. There is hexconverion table at:
      http://www.rapidtables.com/convert/number/how-binary-to-hex.htm
	  Figure out more cool stuff that can be done with hex. 

We will be using hexa(0x) notations in our example as it allows us to represent 4bits in one single digit.
COnsider port number: 6100  
Binary  16bits      : 00010111.11010100
Hex                 :  1   7     D   4   = 17.D4
BigEndianStorage    : 17 -> MemX, D4 -> MemX+1
LittleIndian        : D4 ->MemX, 17 -> MemX+1

Consider IP address: 127.255.255.1
Binary             : 01111111.11111111.11111111.00000001
Hex                :  7    F    F   F   F    F    0   1 = 7F.FF.FF.01
BigEndian          : 7F -> MemX, FF -> MemX+1, FF -> MemX+2, 01 -> MemX+3
LittleEndian       : 01 -> MemX, FF -> MemX+1, FF -> MemX+2, 7F -> MemX+4

-> OK fine, but why are we learning this?
The problem is that some of the system architectures use Big endian while some uses Little endian. SO, when the multibyte data is transfered from 
one host to another it could easily get malformed if both the systems uses different ordering schemes. 
To resolve above issue, someone has done a good job and finalized that all the data passing over network should use BigEndian ordering. So, incase the host uses Little Endian ordering
it has to first convert the data to Big Endian ordering before passing it to the network. 
NOTE: BigEndian ordering is also called Network byte order as all networking protols uses it. Little endian is also called as intel order as most of the intels processors are little endian.

Following are the functions for converting byte order from host order to network order and vice versa. Incase host order == network order, these functions perform no action.
So, its advisable to always use these functions when receiving or sending data to network. This helps the application to function irrespective of the byte order used by host system.

hton() -> convert from host order to network order(used when sending data).
ntoh() -> convert from network order to host order(used when receiving data).

---------------------------------------------------------------------------------------------------------------

pg 1212.





 

























































































































Topics:
How is the server chosen when getaddrinfo() returns multiple ips.



























































#############################################################################################s
Ques: Little endian and Big endian, and how they affect Ip and ports.


SEE section 61.
system limits:
https://unix.stackexchange.com/questions/12985/how-to-check-rx-ring-max-backlog-and-max-syn-backlog-size
Scoket Backlog Q size => Imp as if Q is full connections need to wait and may be discarded too. /proc/sys/net/core/somaxconn
MTU => data is broken into frames of this size by network interface before sending to physical layer. Can be seen in ifconfig.MTU is in bytes
Ephemeral port range: /proc/sys/net/ipv4/ip_local_port_range 















































































































































































