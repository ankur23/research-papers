What are Sockets?
- Sockets are a method of Inter Process Communication that allows data to be exchanged b/w applications running on same host or different hosts.
- A Socket is simply a file descriptor which can be obtained using socket(), system call.
ex:
fd = socket();
- Any socket is described by 5-tuples:
      a: Sender IP.
	  b: Sender Port.
	  c: Receiver IP.
	  d: Receiver Port.
	  e: Communication protocol(TCP/UDP)

Internet Sockets:
--------------------------------------------------------------------------------------------------	  
- There are two types of internet sockets:
    1. Stream Sockets   AKA (SOCK_STREAM)
    2. Datagram Sockets	AKA (SOCK_DGRAM)
 
Stream Sockets (SOCK_STREAM):
------------------------------
Stream sockets are reliable, bi-directional, connection oriented byte stream.

Stream sockets make use of TCP/IP protocol stack.

 - Reliable => Means, if the data is sent, either it will be success or error. i.e no loss of packets.
               Data maintains correct sequencing i.e if we send 123 it will appear at receiver as 123 and 312 or 132.
 
 - Bi-directional => Means, data can be transmitted in either directions.

 - Byte-stream => Means, as with pipes there is no concept of message boundaries.
 
 - Connection oriented => connection is maintained b/w client and server. 
        

Datagram sockets (SOCK_DGRAM):
-------------------------------
Datagram sockets are non-reliable, connection less packets of data.

packets of data => Means, unlike byte-stream there exists message boundaries.
connectionless => No connection is maintained b/w sender and receiver. Its simply a fire and forget strategy.
Non-Reliable => You cannot rely on sequencing of data at receiver end. Also, packet loss can occur.
 
Datagram sockets make use of UDP/IP protocol stack.

Some applications making use of Datagram sockets are: dhcp, ping


Port Numbers:
--------------------
Port numbers are 16-bit numbers. They are used in conjunction with IP addresses as a socket identifier. (For both TCP and UDP)

What if there were no ports and only Ip addresses?
Ans: In such a case a socket can only be identified by 3-tuple i.e sourceIP:DestinationIP:Protocol. Thus, if two applications say mysql and apache needs to execute on same machine
they cannot as both will have same protocol i.e TCP and will have same sourceIP to bind to. Thus, ports helps us to run multiple services on same machine by binding them to 
different ports.  
NOTE: All ports under 1024 are reserved for root user.


Socket System Calls:
--------------------------------------------------------------------------------------
1. socket() :=> Creates a new Socket.
    `int socket(int domain, int type, int protocol);` 
 - domain can be:
    AF_UNIX => For communication b/w applications on same host.
    AF_INET => communication using IPv4 addressing.
    AF_INET6 => communication using IPv6 addressing.

 - type specifies: Whether its a stream socket(SOCK_STREAM) or datagram(SOCK_DGRAM) socket.
 - protocol: This can simply be set to 0 and it will automatically chose correct protocol based on type specified.

2. bind() :=> Now, that you have got the socket. Next step is to specify the IP and Port to which you want to bind this socket. This is done using bind() system call.
   `int bind(int sockfd, struct sockaddr *my_addr, int addrlen);`
    - sockfd => file descriptor obtained from socket() call.
    - sockaddr => IP:Port to bind.
   NOTE: All ports under 1024 are reserved for root user.
   
   TIP: Sometimes, you will see that bind() failes with an error "Address already in use" but actually there is no application using the port. This happens because the application
        has ended, however still the socket binded to port is hanging in kernel. Such a hogging port will automatically get cleared in a minute or so. But if you want to totally remove
        this situation you can add option 'SO_REUSEADDR' in socket options.		
		
3. connect() :=> Now, we have created a socket, binded that socket to an Ip:Port, its time to connect to remote host. This is done via connect() system call.
                 Connect() syscall is used by clients in client-server paradigm.
         `int connect(int sockfd, struct sockaddr *serv_addr, int addrlen);`
          - sockfd => file descriptor obtained from socket() call.
          - sockaddr => Ip:PORT address of remote host.
      NOTE: We can also call connect() without making an explicit call to bind(). In such a case, connect will automatically call bind() internally and will choose a random port to bind socket to. 		  
	  NOTE: connect() is a blocking call and will block till server marks the connection as accepted. See accept().
	
4. listen()	:=> Incase, we are building a server we need to listen for incoming connections. This is done via listen() system call.
             `int listen(int sockfd, int backlog);`
			 - sockfd  => file descriptor obtained from socket() call.
			 - backlog =>  Size of queue in which connections will wait till they are marked as accepted. Default is 20.
	  So, for the server to listen for incoming connections following is the system call sequencing:
	       socket() -> bind() -> listen().
		   NOTE: listen() syscall is always non-blocking.
		   
5. accept() :=> We don't want incoming connections to keep waiting in backlog, so we use accept() system call to pick a connection from backlog queue.
                Along with picking a connection and returning it to us, the accept() call does some extra work too. It creates a new socket for the returned connection
                and this new socket is used for any communication b/w the server and returned client connection.
                The old socket keeps on listening for more client connections.
                Thus, if we have 10 active client connections we have 10+1 sockets. Where 1 (original) socket is listening for more clients and remaining 10 are serving I/O.
				//@todo: better describe this with figure.
           `int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);`
                  - sockfd => original socket descriptor obtained using socket() call.
                  - sockaddr => you dont need to fill this, it will be filled with client Ip and POrt once accept is called. 
				  
				NOTE: Accept() does not opens up a new port on host. It just returns a new socket which uses the servers binded port for communication.


                  127.0.0.1:3306 (sock) (server binded port)             
                  client calling from 1.1.1.1:2202
                  Accept() (sock1) -> [127.0.0.1:3306,1.1.1.1:2202,TCP]
              NOTE: accept() is a blocking call and will block if backlog queue is empty.				  

				

6. send() and recv() :=> These syscalls are used to send and receive data from stream sockets. For datagram sockets use receivefrom() and sendto()
                        NOTE: These needs to be called on new socket descriptor returned from accept() call not on listening socket.
                        NOTE: recv() is a blocking call and will block till an EOF is encountered.						





                         
				  



 				







#############################################################################################s


















































































































































































